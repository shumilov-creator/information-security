# Работа программы "ГОСТ 28147-89"

> Вставляйте скриншоты именно из вашей версии программы: сохраняйте снимки окна с выбранными режимами, ключами и текстом, а в ссылках вместо `path/to/screenshot.png` указывайте реальный путь к сохранённым изображениям.

## 1. Запуск и выбор пользователя

- При запуске появляется окно входа: можно выбрать существующего пользователя или создать нового. Пароль проверяется через локальный файл паролей, а после успешного входа подставляется последний сохранённый ключ.
- После смены пользователя очищаются поля ввода/вывода, обновляются списки адресатов и загружается активный ключ из файла `Ключи.txt` для выбранного профиля.

_Место для скриншота окна входа (возьмите из запущенной программы):_
![Экран входа](path/to/screenshot.png)

## 2. Генерация и хранение ключей

- Ключи представлены как 256-битные значения (64 HEX-символа). Валидация ключа происходит перед каждым шифрованием/расшифрованием.
- Новые ключи можно сгенерировать в окне приложения; ключи сохраняются по пользователю в файл `Ключи.txt` вместе с меткой времени и, при необходимости, пометкой «*current*» как активного ключа.
- Экспорт/импорт ключей выполнен через диалог сохранения/открытия файлов (`*.key` или `*.txt`).

_Место для скриншота генерации/списка ключей (со своим логином и активным ключом):_
![Генерация ключа](path/to/screenshot.png)

**Как сохраняется ключ:** при добавлении уникального ключа для пользователя в `Ключи.txt` записываются имя, сам ключ и штамп времени; при назначении ключа текущим строка помечается `*current*`. При смене пользователя текущий ключ подставляется в поле ввода.

## 3. Шифрование данных (ГОСТ 28147-89)

- Алгоритм реализован на уровне блокового шифра ГОСТ 28147-89 («Тест» S-box). Поддерживаются режимы:
  - **ECB** — базовый блочный режим.
  - **CBC** — сцепление блоков с XOR на входе.
  - **CFB** — потоковый режим на основе шифрования предыдущего блока/IV.
- Перед шифрованием текст переводится в UTF-8 и дополняется паддингом PKCS#5/7 до 8 байт. Для CBC/CFB генерируется случайный 64-битный IV через `BCryptGenRandom`.
- Результат упаковывается в контейнер: префикс `GOST0`, байт режима, IV (8 байт), зашифрованные данные. Контейнер кодируется Base64 для вывода в поле результата и сохранения в файл.

_Место для скриншота основного окна (ключ, режим, текст — снимите именно ваш интерфейс):_
![Основное окно](path/to/screenshot.png)

### 3.1 Подробности ГОСТ 28147-89

Чтобы показать работу алгоритма на скриншотах, полезно понимать, какие шаги выполняет код в `ЗИ.cpp`:

- **S-box «Тест»**: таблица из 8 строк по 16 значений определяет нелинейную замену по 4 бита для каждого раунда.
- **Ключи раундов**: 256-битный ключ делится на 8 32-битных слов (K0–K7). При шифровании они идут три раза подряд прямым порядком (0→7), затем один раз в обратном (7→0) — всего 32 раунда. При расшифровании порядок инвертируется: прямой блок (0→7), затем три прохода (7→0).
- **Раунд** (всего 32):
  1. Складываем левую половину блока с текущим 32-битным ключом по модулю 2³².
  2. Делим результат на 8 полубайт и пропускаем каждый через соответствующую строку S-box.
  3. Циклически сдвигаем получившееся 32-битное слово на 11 бит влево.
  4. XOR с правой половиной блока.
  5. Меняем половины местами (кроме последнего раунда).
- **Дополнение (padding)**: используется PKCS#5/7 на размер блока 8 байт — всегда добавляется от 1 до 8 байт с числом, равным длине заполнения.
- **Инициализационный вектор**: для CBC/CFB генерируется случайный 64-битный IV через системный RNG (`BCryptGenRandom`). В режиме ECB IV не используется.
- **Режимы работы**:
  - *ECB*: каждый 64-битный блок шифруется независимо.
  - *CBC*: перед шифрованием блок XOR-ится с предыдущим шифроблоком (для первого — с IV); при расшифровании обратный XOR выполняется после блочного дешифрования.
  - *CFB*: превращает блочный шифр в потоковый: шифруется предыдущий шифроблок (или IV), результат XOR-ится с открытым текстом; цепочка строится от выходных блоков.

### 3.2 Ключевые фрагменты кода (готовые вставки для Word)

Ниже приведены готовые блоки кода из `ЗИ.cpp` с комментариями. Их можно скопировать в Word и разместить рядом со скриншотами интерфейса или отладчика.

**S-box «Тест» и порядок подключаемых ключей**

```cpp
// Таблица нелинейной замены ГОСТ 28147-89 (вариант «Тест»)
const uint8_t S[8][16] = {
    {4,10,9,2,13,8,0,14,6,11,1,12,7,15,5,3},
    {14,11,4,12,6,13,15,10,2,3,8,1,0,7,5,9},
    {5,8,1,13,10,3,4,2,14,15,12,7,6,0,9,11},
    {7,13,10,1,0,8,9,15,14,4,6,12,11,2,5,3},
    {6,12,7,1,5,15,13,8,4,10,9,14,0,3,11,2},
    {4,11,10,0,7,2,1,13,3,6,8,5,9,12,15,14},
    {13,11,4,1,3,15,5,9,0,10,14,7,6,8,2,12},
    {1,15,13,0,5,7,10,4,9,2,3,14,6,11,8,12}
};

// Расписание раундовых ключей для шифрования (32 раунда)
static const int ENC_K[32] = {
    0,1,2,3,4,5,6,7, 0,1,2,3,4,5,6,7,
    0,1,2,3,4,5,6,7, 7,6,5,4,3,2,1,0
};
```

*Совет для отчёта:* над кодом удобно вставить скрин «Список ключей» и подпись «Раундовые ключи берутся из активного 256-битного ключа пользователя».

**Раундовое шифрование блока (32 раунда, левый/правый полублоки)**

```cpp
void GostEncryptBlock(const uint8_t* in, uint8_t* out, const vector<uint8_t>& k) {
    uint32_t n1 = get_uint32(in), n2 = get_uint32(in + 4);
    uint32_t kk[8];
    for (int i = 0; i < 8; ++i) // разложение 256-битного ключа на 8 слов
        kk[i] = get_uint32(&k[i * 4]);

    for (int r = 0; r < 32; ++r) {
        uint32_t t = n1 + kk[ENC_K[r]]; // сложение по mod 2^32
        uint32_t s = 0;
        // 8 полубайт проходят S-box «Тест»
        for (int i = 0; i < 8; ++i)
            s |= (uint32_t)S[i][(t >> (4 * i)) & 0x0F] << (4 * i);
        s = ROL32(s, 11) ^ n2;         // циклический сдвиг и XOR с правой половиной
        if (r < 31) { n2 = n1; n1 = s; } // обмен половин до финального раунда
        else n2 = s;
    }
    put_uint32(out, n1); put_uint32(out + 4, n2);
}
```

*Как использовать в Word:* вставьте рядом скрин с блок-схемой раунда и стрелками на строки `t = n1 + kk[...]`, «S-box» и «ROL32». Так будет видно, как математические шаги соответствуют GUI-переключателю режима.

**Упаковка контейнера `GOST0` для передачи**

```cpp
vector<uint8_t> GostEncryptContainer(const wstring& text,
                                     const vector<uint8_t>& key,
                                     int mode) {
    string utf8 = WStringToUTF8(text);
    vector<uint8_t> data(utf8.begin(), utf8.end());

    uint8_t pad = 8 - (data.size() % 8); // PKCS#5/7 дополнение
    if (pad == 0) pad = 8;
    data.insert(data.end(), pad, pad);

    uint8_t iv[8] = { 0 };
    if (mode == 1 || mode == 2)
        BCryptGenRandom(NULL, iv, sizeof(iv), BCRYPT_USE_SYSTEM_PREFERRED_RNG);

    // Ветвление по режиму: ECB / CBC / CFB
    // (внутри цикла для каждого 64-битного блока)
    // ...

    const uint8_t magic[5] = { 'G','O','S','T','0' };
    vector<uint8_t> cont;
    cont.insert(cont.end(), magic, magic + 5); // сигнатура контейнера
    cont.push_back((uint8_t)mode);              // байт режима
    cont.insert(cont.end(), iv, iv + 8);        // IV (или нули для ECB)
    cont.insert(cont.end(), out.begin(), out.end());
    return cont; // возвращается до Base64-кодирования
}
```

*Совет:* под кодом вставьте в Word стрелочную схему «Открытый текст → паддинг → IV → блочное шифрование → контейнер GOST0 → Base64». Это покажет, что даже при обмене файлом программа сама прячет IV и выбранный режим.

### 3.3 Контейнер результата `GOST0`

При каждом шифровании приложение упаковывает данные, чтобы их можно было передавать без дополнительной договоренности о параметрах:

- **Структура**: `['G','O','S','T','0'] + байт_режима + IV(8 байт) + шифртекст`.
- **Base64**: весь контейнер кодируется в Base64 для вывода в поле результата и записи в файл. Благодаря префиксу и байту режима при расшифровании не нужно выбирать режим вручную — он извлекается из контейнера.
- **Проверки**: при расшифровании контролируется сигнатура `GOST0`, длина данных кратна 8, валидность паддинга; при ошибке пользователь видит понятное сообщение.

## 4. Расшифрование данных

- При вводе Base64-строки программа декодирует контейнер, проверяет сигнатуру `GOST0`, извлекает режим и IV, а затем выполняет расшифрование выбранным ключом.
- Паддинг проверяется и удаляется; при ошибке формируется сообщение о повреждённых данных или неверном ключе.
- Кнопка «Расшифровать последний» подхватывает последний сохранённый зашифрованный файл текущего пользователя и подставляет его в поле ввода.

_Место для скриншота результата расшифрования (с вашим тестовым текстом):_
![Результат расшифрования](path/to/screenshot.png)

## 5. Автосохранение результатов

- После шифрования или расшифрования результат автоматически сохраняется в папку `Выходные файлы/<пользователь>/` с датой и счётчиком в имени.
- Для зашифрованного текста пишется чистая Base64-строка контейнера; для расшифрованного текста файл дополняется BOM (`UTF-8`) для корректного отображения в редакторах.
- Пользователь может сразу открыть каталог автосохранения через диалог подтверждения.

_Место для скриншота уведомления об автосохранении (из вашей папки автосохранений):_
![Автосохранение](path/to/screenshot.png)

## 6. Обмен сообщениями между пользователями

- В каталоге `Обмен/<пользователь>/` используются две подпапки: `Inbox` (входящие) и `Outbox` (исходящие). Структура создаётся автоматически.
- При отправке сообщение шифруется ключом адресата и записывается в обе папки (входящая адресата и исходящая отправителя) в формате:
  - первая строка `KEY:<ключ_получателя>` для явного указания ключа,
  - далее Base64-контейнер зашифрованных данных.
- Интерфейс обмена показывает списки входящих/исходящих файлов, позволяет обновить, открыть папку или отправить выбранный текст любому сохранённому пользователю.
- Для разбора входящего файла программа выделяет ключ из первой строки и возвращает полезную нагрузку (Base64 контейнера), позволяя сразу расшифровать сообщение.

_Место для скриншота окна обмена (ваши входящие/исходящие):_
![Окно обмена](path/to/screenshot.png)

## 7. Подсказки и валидация

- Поля ввода сопровождаются подсказками с описанием режимов, требований к ключам и назначением кнопок.
- Перед шифрованием/расшифрованием контролируется факт входа пользователя и корректность ключа; при ошибках выводятся диалоги с пояснениями.

_Место для скриншота подсказок/ошибки (покажите сообщения из вашего клиента):_
![Подсказка](path/to/screenshot.png)

---

Этот документ можно использовать как пошаговую шпаргалку: добавьте реальные скриншоты приложения в отмеченные блоки, чтобы показать работу GUI, генерацию ключей, шифрование, автосохранение и обмен сообщениями.
